
%% Copyright (c) 2010, Huiqing Li, Simon Thompson
%% All rights reserved.
%%
%% Redistribution and use in source and binary forms, with or without
%% modification, are permitted provided that the following conditions are met:
%%     %% Redistributions of source code must retain the above copyright
%%       notice, this list of conditions and the following disclaimer.
%%     %% Redistributions in binary form must reproduce the above copyright
%%       notice, this list of conditions and the following disclaimer in the
%%       documentation and/or other materials provided with the distribution.
%%     %% Neither the name of the copyright holders nor the
%%       names of its contributors may be used to endorse or promote products
%%       derived from this software without specific prior written permission.
%%
%% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS''
%% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
%% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
%% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
%% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
%% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
%% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
%% BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
%% WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLI
%% OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
%% ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%% =====================================================================
%% A module for detecting bad coding smells.
%%
%% Author contact: hl@kent.ac.uk, sjt@kent.ac.uk
%% 
%% =====================================================================


%% NOTE:: THIS MODULE IS IN NEED OF REAFCTORING AND DOCUMENTATION!!!

-module(wrangler_modularity_inspection).


-export([gen_module_graph/4, gen_function_callgraph/3]).

-export([cyclic_dependent_modules/3,
	 improper_inter_module_calls/2, 
	 partition_exports/4,
	 partition_exports_eclipse/4,
	 component_extraction_suggestion/1]).

-export([modules_with_big_fanin/4, modules_with_big_fanout/4]).

-define(SimiScore, 0.2).  
-define(DefaultDist, 0.8).

-include("../include/wrangler.hrl").


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Module graph generation.                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-spec (gen_module_graph/4::(filename(), string(), [filename()|dir()], boolean()) ->true).
gen_module_graph(OutFile, NotCareMods, SearchPaths, WithLabel) ->
    ?wrangler_io("\nCMD: ~p:gen_module_graph(~p, ~p, ~p, ~p).\n",
		 [?MODULE, OutFile, NotCareMods, SearchPaths, WithLabel]),
    NotCareMods1 = [list_to_atom(T)|| T<-string:tokens(NotCareMods, ", ")],
    refac_module_graph:module_graph_to_dot(OutFile, NotCareMods1, SearchPaths, WithLabel).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Call Graph Generation.                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
-spec(gen_function_callgraph/3::(filename(), filename(),[filename()|dir()]) ->true).
gen_function_callgraph(OutFile, FileName, SearchPaths)->
     ?wrangler_io("\nCMD: ~p:gen_function_callgraph(~p, ~p, ~p).\n",
 		 [?MODULE, OutFile, FileName, SearchPaths]),
     wrangler_callgraph_server:fun_callgraph_to_dot(OutFile, FileName).
   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Detect and Remove Improper Inter-module calles.                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

improper_inter_module_calls(OutFile, SearchPaths) ->
    ?wrangler_io("\nCMD: ~p:improper_inter_module_calls(~p, ~p).\n",
		   [?MODULE, OutFile, SearchPaths]),
    ModCallerCallees = refac_module_graph:module_graph_with_funs(SearchPaths),
    FullMG = digraph:new(),
    refac_module_graph:add_edges(ModCallerCallees, [], FullMG),
    ModNames = digraph:vertices(FullMG),
    Files = refac_util:expand_files(SearchPaths, ".erl"),
    NonAPIFunsWithDepMods = lists:flatmap(fun (F)->non_api_funs(F, ModNames) end, Files),
    NonAPIFuns = element(1, lists:unzip(NonAPIFunsWithDepMods)),
    %% Module dependency generated by only improper funonction calls.
    ImroperDepMG = lists:append([[{CallerMod, [{CalleeMod, CalledFuns}]}
				  || {CalleeMod, CalledFuns} <- CalleeMods,
				     is_sub_list([{CalleeMod, F, A} || {F, A} <- CalledFuns], NonAPIFuns)]
				 || {CallerMod, CalleeMods} <- ModCallerCallees]),
    refac_module_graph:module_graph_to_dot(OutFile, ImroperDepMG, true),
    ImproperModDeps = [{[CallerMod], {CalleeMod, CalleeFun, CalleeFunArity}}
		       || {{CallerMod, _}, CalleeMods} <- ImroperDepMG,
			  {CalleeMod, CalleeFuns} <- CalleeMods,
			  {CalleeFun, CalleeFunArity} <- CalleeFuns],
    case ImproperModDeps of
	[] ->
	    ?wrangler_io("\n No improper inter-module dependencies have been found.\n",[]);
	_ ->
	    GroupedEdges = refac_misc:group_by(2, ImproperModDeps),
	    RefacSuggestions = [find_best_target_module(ImproperModDeps, EdgeGroup, NonAPIFunsWithDepMods, FullMG, Files) 
				|| EdgeGroup <- GroupedEdges],
	    ?wrangler_io("\n Refactoring suggestions:\n",[]),
	    ?wrangler_io(RefacSuggestions,[]),
	    ?wrangler_io("\n",[])
    end,
    digraph:delete(FullMG).
    

%%TODO: compare the result of using NonAPIs and ClosedNonAPIs.
non_api_funs(FileName, ModNames) ->
    element(3, api_and_non_api_funs(FileName, ModNames)).


api_funs(File, ModNames) ->
    element(1, api_and_non_api_funs(File, ModNames)).


api_and_non_api_funs(File, ModNames) ->
    ExpFuns = exported_funs(File),
    #callgraph{callercallee = CallerCallees} =
	wrangler_callgraph_server:get_callgraph([File]),
    CG = digraph:new(),
    add_edges(CallerCallees, CG),
    SCCs = [SCC || SCC <- digraph_utils:strong_components(CG), length(SCC) > 1],
    Reaching = [{V, digraph_utils:reaching([V], CG)} || V <- ExpFuns],
    %% APIs funs 
    APIs = [V || {V, Rs} <- Reaching, Rs == [V] orelse
					lists:any(fun (SCC) -> Rs == SCC end, SCCs)],
    
    %% Semi APIs are also treated as APIs.
    SemiAPIs = [F || F <- ExpFuns -- APIs, cal_APIScore(F, APIs, CG) >= ?SimiScore],
    
    NonAPIs = ExpFuns -- APIs ++ SemiAPIs,
    
    ClosedNonAPIs = [V || V <- NonAPIs, is_closed(V, CG)],
    
    NonAPIReachableMods = [{V, [V1||V1<-reachable_mods(V, CG), lists:member(V1, ModNames)]} 
			   || V <- ClosedNonAPIs],
    
    digraph:delete(CG),
    
    {APIs, SemiAPIs, NonAPIReachableMods, ClosedNonAPIs}.


%% What other metrics to use: use of records.
cal_APIScore(V, APIs, CG) ->
    VReachable = ordsets:from_list(digraph_utils:reachable([V], CG)),
    Reaching = digraph_utils:reaching([V], CG),
    ReachingAPIs = [R || R <- Reaching, lists:member(R, APIs)],
    Dist = fun (_V, API) ->
		   APIReachable = ordsets:from_list(digraph_utils:reachable([API], CG)),
		   Res = 1 - 2 * ordsets:size(ordsets:intersection([VReachable, APIReachable])) /
			   (ordsets:size(VReachable) + ordsets:size(APIReachable)),
		   Res
	   end,
    APIScore = case ReachingAPIs of
		 [] -> 1;
		 _ -> 1 - lists:min([Dist(V, R) || R <- ReachingAPIs])
	       end,
    APIScore.


%% A function is closed if it does not share any nodes with other functions and 
%% is reachable from the function.
is_closed(V= {M, _F, _A}, CG) ->
    Rs = [{M1, F1, A1} || {M1, F1, A1} <- digraph_utils:reachable([V], CG),
			  M == M1],
    InEdges=lists:sort([{V1, V2}|| R<-Rs, R/=V, E<-digraph:in_edges(CG,R), 
				   {_, V1, V2, _}<-[digraph:edge(CG, E)]]),
    OutEdges=lists:sort([{V1, {M2, F2, A2}}|| R<-Rs, E<-digraph:out_edges(CG,R), 
					      {_, V1, {M2, F2,A2}, _}<-[digraph:edge(CG, E)], M2==M]),
    InEdges == OutEdges.


%% The new function should be an API function in the target module;
%% so don't move a function to a target module where the function 
%% still remains to be a non-API function.

find_best_target_module(LinksToRemove, EdgeGroup, NonAPIFunsWithDepMods,MG, Files) ->
    %% delete the improper dependency edges from the module graph.
    EdgesRemoved=[digraph:edge(MG, L)||L<-LinksToRemove],
    digraph:del_edges(MG, LinksToRemove),
    {CallerMods1, [{DefMod, Fun, Arity}|_]} = lists:unzip(EdgeGroup),
    CallerMods=lists:usort([DefMod|lists:append(CallerMods1)]),
    CommonCalledMods=sets:to_list(sets:intersection([sets:from_list([M|digraph:out_neighbours(MG, M)])
						     ||M<-CallerMods]))--[DefMod],
    DepMods = case lists:keysearch({DefMod, Fun, Arity},1, NonAPIFunsWithDepMods) of
		  {value, {{DefMod, Fun, Arity}, Ms}} ->
		      Ms;
		  _ -> []
	      end,
    SubMG = digraph_utils:subgraph(MG, DepMods, []),
    CondensedSubMG = digraph_utils:condensation(SubMG),
    OrderedDepMods =digraph_utils:topsort(CondensedSubMG),
    TargetMods =case OrderedDepMods of 
		    [] ->
			CommonCalledMods;
		    _ -> sets:to_list(sets:intersection(sets:from_list(CommonCalledMods),
					    sets:from_list(hd(OrderedDepMods))))
		end,
    TargetMods1=[Mod||Mod<-TargetMods, not(is_behaviour_file(Mod, Files))],

    %% TODO: for each target module, calcuate how close the non_api it to the target module!!!.

    Res = "refac_move_fun:move_fun({" ++ atom_to_list(DefMod) ++ "," ++ atom_to_list(Fun) ++ "," ++ integer_to_list(Arity) ++
	 	    "}," ++ format_mod_names(TargetMods1) ++ ").",
    [digraph:add_edge(MG, E, V1, V2, Label)||{E, V1, V2, Label}<-EdgesRemoved],
    lists:flatten(Res).

    
format_mod_names([]) -> "[]";
format_mod_names(Ms) ->
     "[" ++ format_mod_names_1(Ms).

format_mod_names_1([]) ->
    "";
format_mod_names_1([F|T]) ->
    case T of 
	[] ->
	   io_lib:format("~p]", [F])++
		format_mod_names_1(T);
	_ ->
	    io_lib:format("~p,", [F])++
		format_mod_names_1(T)
    end.

reachable_mods(V={M,_F,_A}, CG) ->
    Ms=[M1|| {M1, _F1, _A1} <- digraph_utils:reachable([V], CG),  M /= M1],
    lists:usort(Ms).

get_funs(File, OnlyAPIs) ->
    {ok, {AnnAST, Info}} = refac_util:parse_annotate_file(File, true, []),
    Forms = refac_syntax:form_list_elements(AnnAST),
    MFAs=[case lists:keysearch(fun_def,1,refac_syntax:get_ann(Form)) of 
	      {value, {fun_def, {M, F, A, _,_}}} ->
		  case refac_misc:is_callback_fun(Info,F,A) or is_gen_server_fun(Form) of
		      true ->[];
		      false ->
			  case OnlyAPIs of 
			      true ->
				  case refac_misc:is_exported({F,A}, Info) of
				      true ->
					  [{M, F, A}];
				      false ->
					  []
				  end;
			      false ->
				  [{M, F, A}]				  
			  end
		  end;
	      false ->
		  []
	  end || Form<- Forms],
    lists:append(MFAs).

is_gen_server_fun(FunDef) ->
   lists:member(gen_server, called_mods(FunDef)).

exported_funs(File) ->
    {ok, {_, Info}} = refac_util:parse_annotate_file(File, true),
    ModName = get_module_name(File, Info),
    ImpExports = 
	case lists:keysearch(attributes, 1, Info) of
	    {value, {attributes, Attrs}} ->
		case lists:member({compile, export_all}, Attrs) of
		    true -> 
			case lists:keysearch(functions, 1, Info) of
			    {value, {functions, Funs}} ->
				[{ModName, F, A}||{F, A}<-Funs];
			    false ->
				[]
			end;
		    false ->
			[]
		end;
	    false -> []
	end,
    case ImpExports of
	[] ->
	    case lists:keysearch(exports, 1, Info) of
	      {value, {exports, ExpFuns}} ->
		    [{ModName, F, A}||{F, A}<-ExpFuns];
		false ->
		    []
	    end;
	_ -> ImpExports
    end.


get_module_name(FName, Info) ->
    case lists:keysearch(module, 1, Info) of
	{value, {module, Mod}} -> Mod;
	_ -> list_to_atom(filename:basename(FName, ".erl"))
    end.

   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                     %%
%%  Detecte and  removed cyclic module dependences.                    %%
%%                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Instead of trying to break a SCC, I should try to break cycles.
cyclic_dependent_modules(OutFile, SearchPaths, WithLabel) ->
    ?wrangler_io("\nCMD: ~p:cyclic_dependent_modules(~p, ~p, ~p).\n",
		 [?MODULE, OutFile, SearchPaths, WithLabel]),
    Files = refac_util:expand_files(SearchPaths, ".erl"),
    ModCallerCallees = refac_module_graph:module_graph_with_funs(SearchPaths),
    MG = digraph:new(),
    refac_module_graph:add_edges(ModCallerCallees,[],MG),
    SCCs = digraph_utils:cyclic_strong_components(MG),
    Cycles = [digraph:get_short_cycle(MG, V) || SCC<-SCCs, V <-SCC],
    Cycles1 = remove_duplicated_cycles(Cycles),
    CycleWeakestLinkPairs= [{C, break_a_cycle(C, ModCallerCallees, MG, Files)}|| C<-Cycles1],
    case CycleWeakestLinkPairs of 
	[] ->
	    ?wrangler_io("\nNo cyclic module dependencies have been found.\n", []);
	_ ->		
	    cycles_to_dot(MG, OutFile,CycleWeakestLinkPairs)
    end,
    digraph:delete(MG).


remove_duplicated_cycles(Cs) ->
    remove_duplicated_cycles(Cs, []).

remove_duplicated_cycles([], Acc) ->
    Acc;
remove_duplicated_cycles([C|Cs], Acc) ->
    case lists:any(fun(C1) ->
			   lists:usort(C)==lists:usort(C1) 
		   end, Acc) of 
	true ->
	    remove_duplicated_cycles(Cs, Acc);
	false ->
	    remove_duplicated_cycles(Cs, [C|Acc])
    end.
	

cycles_to_dot(MG, OutFile, CycleWeakestLinkPairs)->
    CycleEdges=[get_cycle_edges(MG, C, WeakestLink)||
		   {C, WeakestLink}<-CycleWeakestLinkPairs],
    NewEdgeList=get_renamed_edge_list(CycleEdges),
    edge_list_to_dot(lists:append(NewEdgeList), OutFile, "ModuleGraph", true).
   
    
get_cycle_edges(MG, C, WeakestLink) ->
    get_cycle_edges(MG, C, WeakestLink, []).

get_cycle_edges(MG, T, {WeakestLink, NodeToColor}, Edges)  when length(T)=<1->
    Edges1 =lists:reverse(Edges),
    [{X, Y, Label, {X,Y}==WeakestLink, case X==NodeToColor of
					   true -> 1;
					   false -> 0
				       end}|| E<-digraph:edges(MG),
				       {_, X, Y, Label} <- [digraph:edge(MG, E)],
				       lists:member({X, Y}, Edges1)];
get_cycle_edges(MG,[V1, V2|T], WeakestLink,  Edges) ->
    get_cycle_edges(MG, [V2|T], WeakestLink, [{V1,V2}|Edges]).

			
get_renamed_edge_list(Cycles) ->
    get_renamed_edge_list_1(Cycles, [], []).
get_renamed_edge_list_1([], _Vs, Acc) ->
    lists:reverse(Acc);
get_renamed_edge_list_1([C|Cs],Vs,Acc) ->
    {NewVs, NewEdges}=get_renamed_edge_list_2(C, Vs, []),
    get_renamed_edge_list_1(Cs, NewVs, [NewEdges|Acc]).

get_renamed_edge_list_2(C, Vs, Edges) ->
    get_renamed_edge_list_3(C, Vs, [], Edges).

get_renamed_edge_list_3([],Vs, NewVs,  NewEdges) ->
    {Vs++lists:usort(NewVs), lists:reverse(NewEdges)};
get_renamed_edge_list_3([{X, Y, Label, Weak, Score}|T], Vs, NewVs, NewEdges) ->
    N=length([X||V<-Vs, X==V]),
    X1 = atom_to_list(X)++"("++integer_to_list(N)++")",
    N1 =length([Y||V<-Vs, Y==V]),
    Y1 = atom_to_list(Y)++"("++integer_to_list(N1)++")",
    get_renamed_edge_list_3(T, Vs, [X,Y|NewVs], [{{X1, X}, {Y1, Y}, Label, Weak, Score}|NewEdges]).    
	    


break_a_cycle(Cycle, ModCallerCallees, MG, Files) ->
    CycleCallerCallees0 = get_cycle_caller_callees_1(Cycle, ModCallerCallees),
    case find_weakest_link(CycleCallerCallees0, MG, Files) of 
	{WeakestLink, RefacCmds} -> 
	    ?wrangler_io("Cyclic module dependency caused by exporting of non-API functions:\n~p\n", [Cycle]),
	    ?wrangler_io("\n Refactoring suggestions:\n",[]),
	    ?wrangler_io("\n~p\n", [RefacCmds]),
	    {WeakestLink,'_'};
	none ->
	    CycleCallerCallees = get_cycle_caller_callees(Cycle, ModCallerCallees),
	    FlawMods= lists:filter(fun({_Mod, _, Callers, Callees, IsBehaviour}) ->
					   list_insection(Callers, Callees)==[] andalso
					       not IsBehaviour					       
				   end, CycleCallerCallees),
	    case FlawMods of 
		[] -> 
		    ?wrangler_io("Intra-layer cyclic module dependency found:~p\n",[Cycle]),
		    {{'_','_'},'_'};
		_ -> 
		    ?wrangler_io("\nInter-layer cyclic module dependency found:~p\n",[Cycle]),
		    FlawMods1=lists:sort(fun({_,_,_,Fs1,_},{_,_,_,Fs2, _})->
						    length(Fs1)=<length(Fs2)
					    end, FlawMods),
		    {M, _, FunsToMove,_,_}=hd(FlawMods1),
		    ?wrangler_io("Refactoring suggestion:\n",[]),
		    ?wrangler_io("move_fun(~p, ~p, user_supplied_target_mod).\n", [M, FunsToMove]),
		    {{'_','_'}, M}
	    end  
    end.

%% dependendency caused only be non-api links.
find_weakest_link(CycleCallerCallees, MG, Files) ->
    ModNames = digraph:vertices(MG),
    ScoredLinks = [score_a_link(Link, ModNames) || Link <- CycleCallerCallees],
    NonAPILinks = [{Link, NonAPIDeps, length(NonAPIDeps), APIDeps} || {Link, NonAPIDeps, APIDeps} <- ScoredLinks,
								      APIDeps == []],
    case NonAPILinks /= [] of
      true ->
	  %% sort by the number of dependencies.
	    {{M1, M2}, NonAPIDepsWithDepMods, _, _} = hd(lists:keysort(2, NonAPILinks)),
	    LinksToRemove = [{M1, M2}],
	    EdgeGroups = [[{get_caller_mods(MG, MFA), MFA}] || {_M, MFA, _} <- NonAPIDepsWithDepMods],
	    RefacSuggestions= [find_best_target_module(LinksToRemove, EdgeGroup, NonAPIDepsWithDepMods, MG, Files)
			       || EdgeGroup<-EdgeGroups],
	    {{M1, M2}, RefacSuggestions};
	false ->
	    none
    end.
  
    
score_a_link(_Link={M1, M2, {File, FAs}}, ModNames) ->    
    #callgraph{callercallee = CallerCallees} =
	wrangler_callgraph_server:get_callgraph([File]),
    CG = digraph:new(),
    add_edges(CallerCallees, CG),
    APIScorePairs= api_score_pairs(File),
    NonAPIDeps=[{M1, {M2,F, A}}|| {{_M, F, A}, APIScore, MoveScore}<-APIScorePairs, 
				  lists:member({F, A}, FAs),
				  APIScore =< ?SimiScore 
				      andalso MoveScore==0],
    NonAPIFunsWithDepMods=[{CallerMod, CalledFun, [M||M<-reachable_mods(CalledFun, CG), lists:member(M, ModNames)]}
			   ||{CallerMod, CalledFun} <-NonAPIDeps],
    APIDeps=[{M1, {M2,F, A}}|| {{_M, F, A}, APIScore, MoveScore}<-APIScorePairs, 
			       lists:member({F, A}, FAs),
			       APIScore > ?SimiScore orelse MoveScore/=0],
    digraph:delete(CG),
    {{M1, M2}, NonAPIFunsWithDepMods, APIDeps}.
  

    
get_caller_mods(MG, {M,F,A}) ->
    Edges = digraph:edges(MG),
    [M1||E<-Edges, {_, M1, M2, Label}<-[digraph:edge(MG, E)], M2==M, 
	 lists:member({F,A}, Label)].
    
api_score_pairs(File) -> 
    ExpFuns =exported_funs(File),
    #callgraph{callercallee = CallerCallees} =
	wrangler_callgraph_server:get_callgraph([File]),
     CG = digraph:new(),
     add_edges(CallerCallees, CG),
     Vs=digraph:vertices(CG),
     SCCs = [SCC||SCC<-digraph_utils:strong_components(CG), length(SCC)>1],
     Reaching =[{V, digraph_utils:reaching([V], CG)} ||
 		  V <-Vs, lists:member(V, ExpFuns)],
     APIs = [V|| {V, Rs}<-Reaching, lists:member(V, ExpFuns), Rs==[V] orelse 
 		    lists:any(fun(SCC)->Rs==SCC end, SCCs)],
     [{V, cal_APIScore(V,APIs,CG), unmoveability(V, CG)}||V<-ExpFuns].
  


unmoveability(V={M,_F, _A}, CG) ->
    ExtMods = [M1||{M1, _F1, _A1} <- digraph_utils:reachable([V], CG),
 			  M /= M1],
    case lists:member(gen_server, ExtMods) of 
 	true -> 
	    1;
 	_ ->
	     case is_closed(V, CG) of 
		 true ->
		     0;
		 false ->
		     1
	     end
     end.


get_cycle_caller_callees_1(Cycle, ModCallerCallees) ->
    get_cycle_caller_callees_1(Cycle, ModCallerCallees,[]).
	
get_cycle_caller_callees_1(Vs, _ ,Acc) when length(Vs) =<1 ->
	    lists:reverse(Acc);
get_cycle_caller_callees_1([V1, V2|T], ModCallerCallees, Acc) ->
	    CalleeFileName=hd([filename:join([Dir, atom_to_list(V2)++".erl"])||
				  {{CallerMod, Dir}, _}<-ModCallerCallees, CallerMod==V2]),
	    CalledFAs = [CalledFuns||{{CallerMod, _}, CalleeMods}<- ModCallerCallees,
	                              CallerMod==V1,
	                              {CalleeMod, CalledFuns}<-CalleeMods,
	                              CalleeMod == V2],
	    get_cycle_caller_callees_1([V2|T], ModCallerCallees, [{V1,V2, {CalleeFileName, hd(CalledFAs)}}|Acc]).
	    
    
get_cycle_caller_callees(Cycle, ModCallerCallees) ->
    Cycle1 = [hd(lists:nthtail(length(Cycle)-2, Cycle))|Cycle],
    get_cycle_node_caller_callees(Cycle1, ModCallerCallees,[]).

get_cycle_node_caller_callees(Vs, _ ,Acc) when length(Vs) =<2 ->
    lists:reverse(Acc);
get_cycle_node_caller_callees([V1, V2, V3|T], ModCallerCallees, Acc) ->
    CalledFunsV2V3=[{V3, F,A}||{{CallerMod, _}, CalleeMods}<- ModCallerCallees, 
			      CallerMod==V2, 
			    {CalleeMod, CalledFuns}<-CalleeMods,
			    CalleeMod == V3, {F,A}<-CalledFuns],
    CalledFunsV2=[{V2,F,A}||{{CallerMod, _}, CalleeMods}<- ModCallerCallees, 
			       CallerMod==V1, 
			       {CalleeMod, CalledFuns}<-CalleeMods,
			       CalleeMod == V2, {F,A}<-CalledFuns],
    V2FileName=hd([filename:join([Dir, atom_to_list(V2)++".erl"])||
		      {{CallerMod, Dir}, _}<-ModCallerCallees, CallerMod==V2]),
    CallerAPIFunsV2= get_caller_funs(V2FileName, CalledFunsV2V3, api_funs(V2FileName,[])), 
    CallerExpFunsV2= get_caller_funs(V2FileName, CalledFunsV2V3, exported_funs(V2FileName)),
    get_cycle_node_caller_callees([V2,V3|T], ModCallerCallees, 
				  [{V2, CallerExpFunsV2, CallerAPIFunsV2, CalledFunsV2, 
				    is_behaviour_file(V2FileName)}|Acc]).

get_caller_funs(File, CalledFuns, Funs) -> 
    #callgraph{callercallee = CallerCallees} =
	wrangler_callgraph_server:get_callgraph([File]),
    CG = digraph:new(),
    add_edges(CallerCallees, CG),
    Reaching =[digraph_utils:reaching([V], CG) ||
		    V <-CalledFuns],
    digraph:delete(CG),
    list_insection(lists:append(Reaching), Funs).
    
called_mods(Tree) ->
    Fun= fun(T,S) ->
		 case refac_syntax:type(T) of
		     application ->
			 Op = refac_syntax:application_operator(T),
			 case lists:keysearch(fun_def, 1, refac_syntax:get_ann(Op)) of
			      {value, {fun_def, {M, F, _A, _, _}}} 
			       when M =/= '_' andalso F =/= '_' ->
				 ordsets:add_element(M ,S);
			     _ ->
				 S
			 end;
		     _ ->S
		 end
	 end,
    ordsets:from_list(refac_syntax_lib:fold(Fun, ordsets:new(), Tree)).
    
		       

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                     %%
%%  Detect and eliminate modules with very big fanin.                  %%
%%                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

modules_with_big_fanin(DotFile, SearchPaths, MinInDegree, NotCareMods) ->
    ModCallerCallees = refac_module_graph:module_graph_with_funs(SearchPaths),
    CalleeMods1 = lists:append([element(1, lists:unzip(CalleeMods)) || {_CallerMod, CalleeMods} <- ModCallerCallees]),
    Res = [[{CallerMod, [{CalleeMod, CalledFuns}]} || {CalleeMod, CalledFuns} <- CalleeMods,
						      not lists:member(CalleeMod, NotCareMods),
						      length([M || M <- CalleeMods1, M == CalleeMod]) >= MinInDegree]
	   || {CallerMod, CalleeMods} <- ModCallerCallees],
    refac_module_graph:module_graph_to_dot(DotFile, lists:append(Res), true).

    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                     %%
%%  Detect and eliminate modules with very big fanout.                 %%
%%                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
modules_with_big_fanout(OutFile, SearchPaths, MinOutDegree, NotCareMods) ->
    ModCallerCallees = refac_module_graph:module_graph_with_funs(SearchPaths),
    Res = [{CallerMod, CalleeMods} || {CallerMod, CalleeMods} <- ModCallerCallees,
				      length(CalleeMods) > MinOutDegree, not lists:member(CallerMod, NotCareMods)],
    refac_module_graph:module_graph_to_dot(OutFile, Res, false).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                     %%
%%  Some utility functions.                                            %%
%%                                                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




list_insection(L1, L2) ->
    ordsets:to_list(ordsets:intersection(ordsets:from_list(L1), ordsets:from_list(L2))).

list_subtract(L1, L2) ->
    ordsets:to_list(ordsets:subtract(ordsets:from_list(L1), ordsets:from_list(L2))).

is_sub_list(L1, L2) ->
    ordsets:is_subset(ordsets:from_list(L1), ordsets:from_list(L2)).

add_edges([], MG) ->
    MG;
add_edges([{Caller, Callees}|Left], MG) ->
    Edges =[{Caller, Callee} ||  Callee <- Callees],
    add_edges(Left, digraph_add_edges(Edges, MG)).

digraph_add_edges([], MG)-> 
    MG;
digraph_add_edges([{From, To}|Left],  MG) ->
    digraph_add_edges(Left,digraph_add_edge(From, To, MG)).   
    
    
digraph_add_edge(From, To,  MG) ->
    case digraph:vertex(MG, From) of 
	false ->
	    digraph:add_vertex(MG, From);
	{From, _} ->
	    ok
    end,
    case digraph:vertex(MG, To) of 
	false ->
	    digraph:add_vertex(MG, To);
	{To,_} -> ok
    end,
    digraph:add_edge(MG, From, To),
    MG.

   
edge_list_to_dot(Edges, OutFileName, GraphName, WithLabel) ->
    NodeList=ordsets:to_list(
	       ordsets:from_list(
		 lists:append(
		   [[V1, V2]||{V1, V2, _Label, _Weak, _Score} <- Edges]))),
    NodesToColor = ordsets:to_list(
		      ordsets:from_list(
			[V1||{V1, _V2, _Label, _Weak, Score} <- Edges, Score==1])),
    Start = ["digraph ",GraphName ," {", "node [shape=ellipse fontsize=16 fontname=\"Courier\"];"],
    VertexList = [node_format(V, NodesToColor) ||V <- NodeList],
    End = ["graph [", GraphName, "=", GraphName, "]}"],
    EdgeList = [edge_format(X, Y, Label,WithLabel, Weak) || {X, Y, Label, Weak, _Score} <- Edges],
    String = [Start, VertexList, EdgeList, End],
    file:write_file(OutFileName, list_to_binary(String)).


node_format({V, VLabel}, NodesToColor) ->
    String = io_lib:format("~p", [V]),
    {Width, Heigth} = calc_dim(String),
    W = (Width div 7 + 1) * 0.55,
    H = Heigth * 0.4,
    SL = io_lib:format("~f", [W]),
    SH = io_lib:format("~f", [H]),
    case lists:member({V,VLabel}, NodesToColor) of 
	true ->
	    [String, " [width=", SL, " label=", "\"", 
	     io_lib:format("~p",[VLabel]), 
	     "\"", " heigth=", SH, " color=red, style=filled", " ", "", "];\n"];
	false ->
	    [String, " [width=", SL, " label=", "\"", 
	     io_lib:format("~p", [VLabel]), 
	     "\"", " heigth=", SH, " ", "", "];\n"]
    end.

calc_dim(String) ->
  calc_dim(String, 1, 0, 0).

calc_dim("\\n" ++ T, H, TmpW, MaxW) ->
  calc_dim(T, H+1, 0, erlang:max(TmpW, MaxW));
calc_dim([_|T], H, TmpW, MaxW) ->
  calc_dim(T, H, TmpW+1, MaxW);
calc_dim([], H, TmpW, MaxW) ->
  {refac_misc:max(TmpW, MaxW), H}.

edge_format([],_,_,_,_) ->
    "";
edge_format(_,[],_,_, _) ->
    "";
edge_format({V1,_}, {V2,_}, Label, WithLabel,WithColor) ->
    String = [io_lib:format("~p", [V1]), " -> ",
	      io_lib:format("~p", [V2])],
    case  WithColor of 
	true ->
	    case WithLabel of 
		true ->
		    [String, " [", "label=", "\"", format_label(Label),  "\"", " color=red  fontsize=20 fontname=\"Verdana\"", "];\n"];
		false ->
		    [String, " ["," color=red", "];\n"]
	    end;
	false ->
	    case WithLabel of 
		true ->
		    [String, " [", "label=", "\"", format_label(Label),  "\"",  "fontsize=20 fontname=\"Verdana\"", "];\n"];
		false ->
		    [String, " [", "];\n"]
	    end
    end.
  

format_label([]) ->
    "";
format_label([{F,A}|T]) ->
    case T of 
	[] ->
	    io_lib:format("~p/~p.", [F, A]);
	[{F1, A1}|T1] ->
	    case T1 of 
		[] ->
		    io_lib:format("~p/~p,~p/~p,", [F, A, F1, A1])++format_label(T1);
		_ ->
		    io_lib:format("~p/~p,~p/~p,", [F, A, F1, A1])++"\\n"++format_label(T1)
		end
    end.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                        %%
%%                    Clustering API functions                            %%
%%                                                                        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-spec(partition_exports/4::(File::filename(), DistTreshold::string(), 
			    SearchPaths::[filename()|dir()], TabWidth::integer()) ->
 			{ok, [filename()]}).
partition_exports(File, DistThreshold, SearchPaths, TabWidth) ->
    ?wrangler_io("\nCMD: ~p:partition_exports(~p,~p,~p,~p).\n",
 		 [?MODULE, File, DistThreshold, SearchPaths, TabWidth]),
    DistThreshold1 = get_dist_threshold(DistThreshold),
    partition_exports(File, DistThreshold1, false, SearchPaths, TabWidth, emacs).

-spec(partition_exports_eclipse/4::(File::filename(), DistTreshold::float(),
				    SearchPaths::[filename()|dir()], TabWidth::integer()) ->
					 {ok, [{filename(), filename(), string()}]}).
partition_exports_eclipse(File, DistThreshold, SearchPaths, TabWidth) ->
    partition_exports(File, DistThreshold, false, SearchPaths, TabWidth, eclipse).



partition_exports(File, DistThreshold, WithInOutDegree, SearchPaths, TabWidth, Editor) ->
    Cmd1 = "CMD: " ++ atom_to_list(?MODULE) ++ ":partition_exports(" ++ "\"" ++
	File ++ "\", " ++ float_to_list(DistThreshold) ++
	", " ++ "[" ++ refac_misc:format_search_paths(SearchPaths) ++ "]," 
	++ integer_to_list(TabWidth) ++ ").",
    case exported_funs(File) of
	[] -> throw({error, "This module does not export any functions."});
	_ -> ok
    end,		  
    #callgraph{callercallee = CallerCallees} =
	wrangler_callgraph_server:get_callgraph([File]),
    CG = digraph:new(),
    add_edges(CallerCallees, CG),
    UsedMRWs = used_macros_records_words(File),
    Coms = gen_components(File),
    Matrix = generate_fun_dist_matrix(File, CG, Coms, UsedMRWs, true),
    Mods = [list_to_atom(filename:basename(F, ".erl")) || F <- SearchPaths],
    Cs=agglomerative_cluster(Matrix, CG, Coms, UsedMRWs, DistThreshold, Mods),
    ModName = list_to_atom(filename:basename(File, ".erl")),
    MG = digraph:new(),
    case WithInOutDegree of 
	true ->
	    ModCallerCallees = refac_module_graph:module_graph_with_funs(SearchPaths),
	    refac_module_graph:add_edges(ModCallerCallees, [], MG);
	false ->
	    ok
    end,
    CsWithInOutDegree =[get_in_out_degree(ModName, C, MG, CG) ||C<-Cs],
    NewCs= group_small_clusters(CsWithInOutDegree),
    case WithInOutDegree of 
	true ->
	    [format_a_cluster(C)||C<-NewCs];
	false -> ok
    end,
    digraph:delete(MG),
    digraph:delete(CG),
    AnnAST1=rewrite_export_list(File, NewCs),
    refac_util:write_refactored_files(File, AnnAST1, Editor, Cmd1).
    
    
   

get_dist_threshold(DistThreshold) ->
    try
      case DistThreshold of
	[] -> ?DefaultDist;
	_ ->
	    S = list_to_float(DistThreshold),
	    case S >= 0.0 andalso S =< 1.0 of
	      true -> S;
	      _ -> ?DefaultDist
	    end
      end
    catch
      V2 -> V2;
      _:_ -> throw({error, "Parameter input is invalid."})
    end.
    
used_macros_records_words(File) ->
    {ok, {AnnAST, _Info}} = refac_util:parse_annotate_file(File, true,[]),
    Forms = refac_syntax:form_list_elements(AnnAST),
    [used_macros_records_words_1(F) ||F<-Forms, refac_syntax:type(F)==function].
  
used_macros_records_words_1(FunDef) ->
    UsedMacros= refac_misc:collect_used_macros(FunDef),
    UsedRecords=refac_misc:collect_used_records(FunDef),
    Ann = refac_syntax:get_ann(FunDef),
    {value, {fun_def, {M,F, A, _, _}}} = lists:keysearch(fun_def, 1, Ann),
    Words = collect_words({M,F, A},FunDef),
    {{M,F,A}, {UsedMacros, UsedRecords, Words}}.

collect_words({_M,F,_A}, FunDef) ->
    Fun=fun(Node, Acc) ->
		case refac_syntax:type(Node) of 
		    atom ->
		       	Name = refac_syntax:atom_value(Node),
		       	Acc++string:tokens(atom_to_list(Name), "_");
		    variable ->
			Name = refac_syntax:variable_literal(Node),
			Acc++string:tokens(Name, "_");
		    _ -> Acc
		end
	end,
    lists:usort(refac_syntax_lib:fold(Fun, string:tokens(atom_to_list(F), "_"), FunDef)).

gen_components(FileName) ->
    CallerCalleesWithDef = wrangler_callgraph_server:build_callercallee_callgraph([FileName]),
    CallerCallees = [{{M,F,A}, [{M1,F1,A1}||{M1,F1,A1}<-Callee, M1==M]}
		     || {{{M,F,A}, _}, Callee}<-CallerCalleesWithDef],
    CallerCallees1=[{Caller, Callees}||{Caller, Callees}<-CallerCallees, 
				       Callees/=[]],
    CG = digraph:new(),
    add_edges(CallerCallees1,  CG),
    Coms=digraph_utils:components(CG),
    digraph:delete(CG),
    Coms.

generate_fun_dist_matrix(File, CG, Coms, UsedMRWs, OnlyAPIs) ->
    Funs = get_funs(File, OnlyAPIs),
    IntialMatrix = [{[F], [{[F1], undefined}||F1<-Funs]}||F<- Funs],
    update_dist(IntialMatrix, CG, Coms, UsedMRWs).

agglomerative_cluster(Matrix, CG, Coms, UsedMRWs, DistThreshold, Mods) ->
    agglomerative_cluster(Matrix, CG, Coms,UsedMRWs, DistThreshold, Mods, []).

agglomerative_cluster(_Matric=[_], _CG,  _Coms,_, _,_, Acc) ->
    lists:reverse(Acc);
agglomerative_cluster(Matrix,CG, Coms, UsedMRWs,  DistThreshold, Mods, Acc) ->
    {{RowKey, ColKey}, Dist} = find_min_dist(Matrix),
    case {RowKey, ColKey} == {[],[]} orelse Dist>DistThreshold of 
	true ->
	    [F||{F, _}<- Matrix];
	false ->
	    Matrix1=group_funs(Matrix, {RowKey, ColKey}),
	    %%Matrix2 = update_dist(Matrix1, CG, Coms, UsedMRWs),
	    Cs = [F||{F, _}<- Matrix1],
	    agglomerative_cluster(Matrix1, CG, Coms, UsedMRWs, DistThreshold, Mods, 
				  Cs++Acc)
    end.

   
get_in_out_degree(ModName,Cluster, MG, FileCG) ->
    Fun = fun(V={M, _F, _A}) ->
		  lists:usort([M2||E<-digraph:out_edges(FileCG,V), 
				   {_, _V1, {M2, _F2,_A2}, _}<-[digraph:edge(FileCG, E)], M2/=M])
	  end,
    OutMods = [Fun(V)||V<-Cluster],
    OutDegree=length(lists:usort(OutMods)),
    InEdges=digraph:in_edges(MG, ModName),
    InEdges1=[digraph:edge(MG, E)||E<-InEdges],
    InMods=[M1||{_, M1, _M2, Label}<- InEdges1,
		Label1<-[[{ModName, F,A}||{F, A}<-Label]],
		Cluster--Label1/=Cluster],
    InDegree=length(lists:usort(InMods)),
    {InDegree, OutDegree, Cluster}.
     
    
group_small_clusters(Cs) ->
    Cs1 = lists:sort(fun({_,_,C1}, {_,_,C2}) ->
			     length(C1)>=length(C2)
		     end, Cs),
    Cs2=[C||C<-Cs1, length(element(3,C))>1],
    Cs3 = Cs1--Cs2, 
    Cs4 =case Cs3 of
	     [] -> Cs2;
	     _ ->
		 {In, Out, C}=lists:unzip3(Cs3),
		 Cs2++[{lists:sum(In), lists:sum(Out), lists:append(C)}]
	 end,
    lists:zip(lists:seq(1, length(Cs4)),Cs4).

format_a_cluster({Index, {InMods, OutMods, C}}) ->
    ?wrangler_io("\nGroup ~p: Indegree:~p, OutDegree:~p,\n~p\n", 
		 [Index, InMods, OutMods, C]).


is_attribute(F, Name) ->
    refac_syntax:type(F) == attribute andalso
      refac_syntax:type(refac_syntax:attribute_name(F)) == atom andalso
	refac_syntax:atom_value(refac_syntax:attribute_name(F)) == Name.


make_export(Names) ->
    Es = [refac_syntax:arity_qualifier(refac_syntax:atom(F),refac_syntax:integer(A))
	  || {F, A} <- Names],
    refac_syntax:attribute(refac_syntax:atom('export'), [refac_syntax:list(Es)]).


rewrite_export_list(FName, Cs) ->
    {ok, {AnnAST, _Info}} = refac_util:parse_annotate_file(FName, true, []),
    Forms = refac_syntax:form_list_elements(AnnAST),
    {Forms1, Forms2} = case lists:splitwith(fun (F) ->
						    not is_attribute(F, export)
					    end, Forms)
			   of
			 {_Fs, []} ->
			     case lists:splitwith(fun (F) ->
							  not is_attribute(F, compile)
						  end, Forms)
				 of
			       {_, []} ->
				   throw({error, "No export attribute has been found in the file."});
			       {Fs1, Fs2} ->
				   {Fs1, Fs2}
			     end;
			 {Fs1, Fs2} ->
			     {Fs1, Fs2}
		       end,
    Forms21 = [F || F <- tl(Forms2), not is_attribute(F, export)],
    NewExports = [begin
		    {_, {_, _, MFAs}} = C,
		    FAs = [{F, A} || {_, F, A} <- MFAs],
		    make_export(FAs)
		  end || C <- Cs],
    NewForms = Forms1 ++ NewExports ++ Forms21,
    refac_syntax:form_list(NewForms).

find_min_dist(Matrix) ->
    {{RowKey, ColKey}, Dist}=
	lists:foldl(fun({RowKey, RowElems}, {Acc, Min})->
			    lists:foldl(fun({ColKey, Dist}, {Acc0, Min0}) ->
						case Dist>=Min0 of
						    true -> {Acc0,Min0};
						    false when Dist/=0->
							{{RowKey, ColKey}, Dist};
						    _ -> {Acc0, Min0}
						end
					end, {Acc, Min}, RowElems)
		    end, {{[],[]}, 1}, Matrix),
    {{RowKey, ColKey}, Dist}.

group_funs(Matrix, {C1, C2}) ->
    {value, {C1,RowElems1}} = lists:keysearch(C1,1,  Matrix),
    {value, {C2,RowElems2}} = lists:keysearch(C2, 1, Matrix),
    NewRowElems=[{Es, case D1==0 orelse D2==0 of 
			  true -> 0;
			  _ ->
			      %%(length(C1)*D1+length(C1)*D2) /(length(C1)+length(C2))
			      %%erlang:min(D1,D2)
			      (D1+D2)/2
		      end}
		 || {{Es, D1}, {Es, D2}}<-lists:zip(RowElems1, RowElems2)],
    Matrix1 =[{RowKey1, group_cols(RowKey, NewRowElems1, {C1, C2})}
	      || {RowKey, RowElems} <- Matrix, 
		 {RowKey1, NewRowElems1}<-
		     [case RowKey==C1 orelse RowKey==C2 of 
			  true -> {C1++C2, NewRowElems};
			  false -> {RowKey, RowElems}
		      end]],
    remove_duplicated_keys(Matrix1).
   
    
					
group_cols(_RowKey, RowElems, {C1, C2}) ->
    {value, {C1, D1}}=lists:keysearch(C1,1, RowElems),
    {value, {C2, D2}} =lists:keysearch(C2,1, RowElems),
    NewDist=case D1 ==0 orelse D2 ==0 of 
		true -> 0;
		_ ->
		    (D1+D2)/2
		    %%(length(C1)*D1+length(C1)*D2) /(length(C1)+length(C2))
		%%	erlang:min(D1,D2)
	    end,
    NewRowElems =[{ColKey1, Dist1}||
		     {ColKey, Dist}<-RowElems,
		     {ColKey1, Dist1} <-[case ColKey==C1 orelse ColKey==C2 of
					     true -> {C1++C2, NewDist};
					     false -> {ColKey, Dist}
					 end]],
    remove_duplicated_keys(NewRowElems).

remove_duplicated_keys(Tuples) ->
    remove_duplicated_keys(Tuples, [], []).

remove_duplicated_keys([],_, Tuples1) -> 
    lists:reverse(Tuples1);
remove_duplicated_keys([{Key, V}|T], Keys, Tuples1) ->
    case lists:member(Key, Keys) of
	true ->
	    remove_duplicated_keys(T, Keys, Tuples1);
	false ->
	    remove_duplicated_keys(T, [Key|Keys],[{Key, V}|Tuples1])
    end.

update_dist(Matrix, CG, Coms, UsedMRWs) ->
    [{RowKey, RowElems1} ||{RowKey, RowElems}<-Matrix,
			   RowElems1<-[[{ColKey, Dist1}
					||{ColKey, Dist}<-RowElems,
					  Dist1<-[update_dist(RowKey, ColKey, Dist, CG, Coms, UsedMRWs)]]]].

update_dist(RowKey, ColKey, Dist, CG, Coms, UsedMRWs) ->
    case Dist of 
	undefined ->
	    calculate_dist(RowKey, ColKey, CG, Coms, UsedMRWs);
	_ -> Dist
    end.

calculate_dist(FunGroup1 = [{_M, _F, _A}| _], FunGroup2, CG, _Components, UsedMRWs) ->
    case lists:usort(FunGroup1) == lists:usort(FunGroup2) of
      true -> 0;
      false ->
	  FunGroup1Reachable = digraph_utils:reachable(FunGroup1, CG),
	  FunGroup2Reachable = digraph_utils:reachable(FunGroup2, CG),
	  FunGroup1UsedMRWs = lists:append([Ms ++ Rs ++ Ws || {{M, F, A}, {Ms, Rs, Ws}} <- UsedMRWs,
							      lists:member({M, F, A}, FunGroup1)]),
	  FunGroup2UsedMRWs = lists:append([Ms ++ Rs ++ Ws || {{M, F, A}, {Ms, Rs, Ws}} <- UsedMRWs,
							      lists:member({M, F, A}, FunGroup2)]),
	    FunGroup1Entities = FunGroup1Reachable ++ FunGroup1UsedMRWs,
	    FunGroup2Entities = FunGroup2Reachable ++ FunGroup2UsedMRWs,
	    A = list_insection(FunGroup1Entities, FunGroup2Entities),
	    B = list_subtract(FunGroup1Entities, FunGroup2Entities),
	    C = list_subtract(FunGroup2Entities, FunGroup1Entities),
	    1 - length(A) / (length(A) + length(B) + length(C))
    end.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                        %%
%%              Extract a sub component from a large module               %%
%%                                                                        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
component_extraction_suggestion(File) ->
    ?wrangler_io("\nCMD: ~p:component_extraction_suggestion(~p).\n",
		  [?MODULE, File]),
    Mod = list_to_atom(filename:basename(File, ".erl")),
    #callgraph{callercallee = CallerCallees} =
	wrangler_callgraph_server:get_callgraph([File]),
    CG = digraph:new(),
    add_edges(CallerCallees, CG),
    
    FunSizePairs = get_fun_size_pairs(File, []),
    ExpFuns = exported_funs(File),
    
    Vs = [V || V <- digraph:vertices(CG), element(1, V) == Mod],
    
    InternalFuns = Vs -- ExpFuns,
    
    Res = [moveability(F, CG, FunSizePairs) || F <- InternalFuns],
    Res1 = lists:reverse(lists:keysort(5, Res)),
    ?wrangler_io("\nComponent extraction suggestion:\n",[]),
    ?wrangler_io("{                        Function, LOC to move, LOC left, LOC shared, Score}):\n",[]), 
    format_result(lists:sublist(Res1, 10)).


format_result([]) ->
    ?wrangler_io("\n",[]);
format_result([{{_M,F,A}, Loc1, Loc2, Loc3, Score}|Ts]) ->
    ?wrangler_io("{~30s/~p,     ~p,      ~p,       ~p,       ~p}\n",[F,A, Loc1, Loc2,Loc3,Score]),
    format_result(Ts).
   

moveability(V = {M, _F, _A}, CG, FunSizePairs) ->
    Vs = [{M1, F, A} || {M1, F, A} <- digraph:vertices(CG), M == M1],
    Rs = [{M1, F1, A1} || {M1, F1, A1} <- digraph_utils:reachable([V], CG),
			  M == M1],
    InEdges = lists:sort([{V1, V2} || R <- Rs, R /= V, E <- digraph:in_edges(CG, R),
				      {_, V1, V2, _} <- [digraph:edge(CG, E)]]),
    OutEdges = lists:usort([{V1, {M2, F2, A2}} || R <- Rs, E <- digraph:out_edges(CG, R),
						  {_, V1, {M2, F2, A2}, _} <- [digraph:edge(CG, E)], M2 == M]),
    SharedVs = lists:usort([V2 || {_V1, V2} <- InEdges -- OutEdges]),
    RsSize = get_size(Rs, FunSizePairs),
    SharedVsSize = get_size(SharedVs, FunSizePairs),
    RemainedVsSize = get_size(Vs -- Rs, FunSizePairs),
    {V, RsSize,RemainedVsSize, SharedVsSize,
     refac_misc:min(RsSize - 2 * SharedVsSize, RemainedVsSize) /
     refac_misc:max(RsSize - 2 * SharedVsSize, RemainedVsSize)}.

get_fun_size_pairs(File, SearchPaths)->    
    {ok, {AnnAST, _Info}} = refac_util:parse_annotate_file(File, true, SearchPaths),
    Forms = refac_syntax:form_list_elements(AnnAST),
    Fun = fun(Form) ->
		  case lists:keysearch(fun_def,1,refac_syntax:get_ann(Form)) of 
		      {value, {fun_def, {M, F, A, _,_}}} ->
			  Toks = refac_misc:get_toks(Form),
			  CodeLines = [element(1, element(2, T)) ||
					  T <- Toks, element(1, T) /= whitespace, 
					  element(1, T) /= comment],
			  [{{M, F, A}, length(refac_misc:remove_duplicates(CodeLines))}];
		      false ->
			  []
		  end
	  end,
    lists:append([Fun(F)||F<-Forms]).


get_size(Vs, FunSizePairs) ->
    lists:sum([Size||{F, Size}<-FunSizePairs, lists:member(F, Vs)]).


is_behaviour_file(File) ->
    {ok, {AnnAST, _Info}} = refac_util:parse_annotate_file(File, true, []),
    Forms = refac_syntax:form_list_elements(AnnAST),
    lists:any(fun(F) ->
		      case refac_syntax:type(F) of
			  attribute ->
			      case refac_syntax:type(refac_syntax:attribute_name(F)) of
				  atom ->
				      refac_syntax:atom_value(refac_syntax:attribute_name(F))==behaviour;
				  _ -> false
			      end;
			  _ -> false
		      end
	      end, Forms).
is_behaviour_file(Mod, Files) ->
    case lists:filter(fun(F) ->
			      list_to_atom(filename:basename(F, ".erl"))==Mod
		      end, Files) of
	[File|_] ->
	    is_behaviour_file(File);
	_ ->
	    false
    end.
		
